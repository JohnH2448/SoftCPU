module Dmem #(
    parameter int DEPTH_WORDS = 1024
) (
    input  logic        clock,
    input  logic        reset,

    // From CPU Memory stage
    input  logic [31:0] address,      // Memory.addressRegister
    input  logic [31:0] storeData,    // Memory.storeData (already shifted)
    input  logic [3:0]  byteEnable,   // Memory.realStoreByteEnable (active bytes)
    input  logic        storeValid,   // Memory.storeValid (write request)

    // Back to CPU Memory stage
    output logic [31:0] loadData,      // word read from memory
    output logic        loadDataValid, // 1 iff loadData matches current address
    output logic        storeComplete  // 1 for one cycle when store is done
);

    // Simple word-addressed RAM
    localparam int ADDR_LSB = 2; // ignore byte offset bits [1:0]
    localparam int ADDR_MSB = ADDR_LSB + $clog2(DEPTH_WORDS) - 1;

    logic [31:0] mem [0:DEPTH_WORDS-1];

    // For posedge detection of storeValid
    logic storeValid_q;

    // -------- LOAD PATH (zero-wait-state) --------
    // Combinational read: always present correct data for the *current* address.
    // loadDataValid is 1 whenever we're not in reset, so the handshake degenerates
    // to "always ready" like a single-cycle SRAM.
    always_comb begin
        if (reset) begin
            loadData      = 32'h00000000;
            loadDataValid = 1'b0;
        end else begin
            loadData      = mem[address[ADDR_MSB:ADDR_LSB]];
            loadDataValid = 1'b1;
        end
    end

    // -------- STORE PATH --------
    // On posedge of storeValid, write selected bytes and pulse storeComplete.
    always_ff @(posedge clock) begin
        if (reset) begin
            storeValid_q   <= 1'b0;
            storeComplete  <= 1'b0;
        end else begin
            storeComplete  <= 1'b0; // default: no completion

            // rising edge detect
            if (storeValid && !storeValid_q) begin
                int idx;
                logic [31:0] word;

                idx  = address[ADDR_MSB:ADDR_LSB];
                word = mem[idx];

                // Byte-wise write-enable
                if (byteEnable[0]) word[7:0]   = storeData[7:0];
                if (byteEnable[1]) word[15:8]  = storeData[15:8];
                if (byteEnable[2]) word[23:16] = storeData[23:16];
                if (byteEnable[3]) word[31:24] = storeData[31:24];

                mem[idx]       <= word;
                storeComplete  <= 1'b1;  // write is visible by next cycle's load
            end

            storeValid_q <= storeValid;
        end
    end

endmodule
